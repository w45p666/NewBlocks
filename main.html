<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Interactive Physics Sandbox</title>
<style>
  body { 
    margin: 0; 
    overflow: hidden; 
    background: #f0f2f5; 
    font-family: Arial, sans-serif; 
  }

  /* Professional Top Bar */
  #topbar {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    background: #ffffff;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 20px;
    z-index: 1000;
    gap: 12px;
  }

  #topbar .left, #topbar .center, #topbar .right {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  #topbar button {
    padding: 6px 12px;
    border-radius: 6px;
    border: 1px solid #ccc;
    background: #fff;
    cursor: pointer;
    transition: 0.2s;
  }
  #topbar button:hover { background: #e0e0e0; }

  #topbar input[type=range] { vertical-align: middle; }

  #counter {
    font-size: 0.95em;
  }

  #welcome {
    position: absolute;
    top: 60px; /* under top bar */
    left: 20px;
    font-size: 1.2em;
    background: rgba(255,255,255,0.95);
    padding: 8px 15px;
    border-radius: 8px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    opacity: 1;
    transition: opacity 1s ease-out;
    z-index: 500;
  }

  canvas {
    display: block;
  }
</style>
</head>
<body>
<canvas id="world"></canvas>

<!-- Professional Top Bar -->
<div id="topbar">
  <div class="left">
    <button onclick="spawn('circle')">Circle</button>
    <button onclick="spawn('square')">Square</button>
    <button onclick="spawn('ramp')">Ramp</button>
    <button onclick="resetWorld()">Reset</button>
  </div>
  <div class="center">
    <button onclick="toggleGravity()">Pause/Play Gravity</button>
    <button id="rotateModeBtn" onclick="toggleRotateMode()">Rotate Mode: OFF</button>
    <button id="deleteBtn" onclick="toggleDeleteMode()">Delete Mode: OFF</button>
    <label>Gravity: <input id="gravitySlider" type="range" min="0" max="2" step="0.01" value="1"></label>
  </div>
  <div class="right">
    <div id="counter">Circles: 0 | Squares: 0 | Ramps: 0</div>
    <button onclick="logout()">Logout</button>
  </div>
</div>

<div id="welcome"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
// Matter.js setup
const { Engine, Render, Runner, World, Bodies, Body, Mouse, MouseConstraint, Events, Composite } = Matter;

const engine = Engine.create();
const world = engine.world;
const canvas = document.getElementById('world');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const render = Render.create({
    canvas,
    engine,
    options: { wireframes: false, background: '#f0f2f5', width: canvas.width, height: canvas.height }
});
Render.run(render);
Runner.run(Runner.create(), engine);

// Walls
const walls = [
    Bodies.rectangle(canvas.width/2, canvas.height+50, canvas.width, 100, { isStatic: true }),
    Bodies.rectangle(canvas.width/2, -50, canvas.width, 100, { isStatic: true }),
    Bodies.rectangle(-50, canvas.height/2, 100, canvas.height, { isStatic: true }),
    Bodies.rectangle(canvas.width+50, canvas.height/2, 100, canvas.height, { isStatic: true })
];
World.add(world, walls);

// Mouse
const mouse = Mouse.create(canvas);
const mouseConstraint = MouseConstraint.create(engine, { mouse, constraint: { stiffness: 0.2, render: { visible: false } } });
World.add(world, mouseConstraint);

const ramps = [];
const squares = [];

// Rotate and Delete Modes
let rotateMode = false;
function toggleRotateMode() { rotateMode = !rotateMode; document.getElementById("rotateModeBtn").innerText = `Rotate Mode: ${rotateMode ? 'ON' : 'OFF'}`; }

let deleteMode = false;
function toggleDeleteMode() { deleteMode = !deleteMode; document.getElementById("deleteBtn").innerText = `Delete Mode: ${deleteMode ? 'ON' : 'OFF'}`; }

// Delete objects on click
canvas.addEventListener('mousedown', e => {
    if (!deleteMode) return;
    const mousePos = { x: e.offsetX, y: e.offsetY };
    const allObjects = [...squares, ...ramps, ...world.bodies.filter(b => b.label === "Circle Body")];
    for (let obj of allObjects) {
        if (Matter.Bounds.contains(obj.bounds, mousePos)) {
            Composite.remove(world, obj);
            if (squares.includes(obj)) squares.splice(squares.indexOf(obj), 1);
            if (ramps.includes(obj)) ramps.splice(ramps.indexOf(obj), 1);
            break;
        }
    }
});

// Counters
const counterEl = document.getElementById("counter");
function updateCounter() {
    let circles = 0, squaresCount = squares.length, rampCount = ramps.length;

    world.bodies.forEach(b => {
        if (!b.isStatic && (b.position.y > canvas.height + 100 || b.position.y < -100 || b.position.x < -100 || b.position.x > canvas.width + 100)) {
            if (!b.removed) {
                Composite.remove(world, b);
                b.removed = true;
                if (squares.includes(b)) squares.splice(squares.indexOf(b),1);
            }
        } else {
            if (b.label === "Circle Body") circles++;
        }
    });

    counterEl.innerHTML = `Circles: ${circles} | Squares: ${squaresCount} | Ramps: ${rampCount}`;
}

// Spawn
function spawn(type) {
    const x = Math.random() * (canvas.width - 100) + 50;
    const y = 50;
    let body;
    if (type === 'circle') {
        const r = 30;
        body = Bodies.circle(x, y, r, { restitution: 0.7, render: { fillStyle: '#f39c12' } });
        body.originalRadius = r;
    } else if (type === 'square') {
        const w = 60, h = 60;
        body = Bodies.rectangle(x, y, w, h, { restitution: 0.7, render: { fillStyle: '#3498db' } });
        body.originalWidth = w;
        body.originalHeight = h;
        squares.push(body);
    } else if (type === 'ramp') {
        const w = 200, h = 20;
        const angle = 25 * Math.PI / 180;
        body = Bodies.rectangle(x, y+100, w, h, { isStatic: true, angle: angle, render: { fillStyle: '#2ecc71' } });
        body.originalWidth = w;
        body.originalHeight = h;
        ramps.push(body);
    }
    World.add(world, body);
    updateCounter();
}

// Gravity
let gravityEnabled = true;
function toggleGravity() { gravityEnabled = !gravityEnabled; engine.world.gravity.y = gravityEnabled ? parseFloat(document.getElementById('gravitySlider').value) : 0; }
function updateGravity(value) { if(gravityEnabled) engine.world.gravity.y = parseFloat(value); }
document.getElementById('gravitySlider').addEventListener('input', e => updateGravity(e.target.value));

// Reset
function resetWorld() {
    Composite.clear(world, false);
    World.add(world, walls);
    World.add(world, mouseConstraint);
    ramps.length = 0;
    squares.length = 0;
    updateCounter();
}

// Drag & Rotate ramps
let selectedRamp = null;
Events.on(mouseConstraint, "mousedown", (e) => {
    const mousePos = e.mouse.position;
    if (rotateMode) ramps.forEach(ramp => { if (Matter.Bounds.contains(ramp.bounds, mousePos)) selectedRamp = ramp; });
    else ramps.forEach(ramp => { if (Matter.Bounds.contains(ramp.bounds, mousePos)) selectedRamp = ramp; });
});
Events.on(mouseConstraint, "mousemove", (e) => {
    if (!selectedRamp) return;
    if (rotateMode) {
        const dx = e.mouse.position.x - selectedRamp.position.x;
        const dy = e.mouse.position.y - selectedRamp.position.y;
        Body.setAngle(selectedRamp, Math.atan2(dy, dx));
    } else {
        Body.setPosition(selectedRamp, e.mouse.position);
        if (!selectedRamp.hasBeenRotated) Body.setAngle(selectedRamp, 25*Math.PI/180);
    }
});
Events.on(mouseConstraint, "mouseup", () => { if(selectedRamp && rotateMode) selectedRamp.hasBeenRotated = true; selectedRamp = null; });

// Save & Load
function saveProgress() {
    const data = [];
    world.bodies.forEach(b => {
        if (!b.isStatic && !b.removed) {
            const type = (b.label === "Circle Body") ? "circle" : "square";
            data.push({ type, x:b.position.x, y:b.position.y, angle:b.angle, radius:b.originalRadius||0, width:b.originalWidth||0, height:b.originalHeight||0 });
        }
    });
    ramps.forEach(r => data.push({ type:"ramp", x:r.position.x, y:r.position.y, angle:r.angle, width:r.originalWidth, height:r.originalHeight }));
    localStorage.setItem("sandboxData", JSON.stringify(data));
}
function loadProgress() {
    const dataStr = localStorage.getItem("sandboxData");
    if(!dataStr) return;
    const data = JSON.parse(dataStr);
    data.forEach(obj => {
        let body;
        if(obj.type=="circle") body = Bodies.circle(obj.x,obj.y,obj.radius,{ restitution:0.7, render:{fillStyle:'#f39c12'} });
        else if(obj.type=="square"){ body = Bodies.rectangle(obj.x,obj.y,obj.width,obj.height,{ restitution:0.7, render:{fillStyle:'#3498db'} }); squares.push(body);}
        else if(obj.type=="ramp"){ body = Bodies.rectangle(obj.x,obj.y,obj.width,obj.height,{ isStatic:true, angle:obj.angle, render:{fillStyle:'#2ecc71'} }); ramps.push(body);}
        if (obj.radius) body.originalRadius = obj.radius;
        if (obj.width) body.originalWidth = obj.width;
        if (obj.height) body.originalHeight = obj.height;
        World.add(world,body);
    });
}
window.addEventListener("load",()=>{loadProgress();updateCounter();});
window.addEventListener("beforeunload",()=>{saveProgress();});

// Welcome
const username = localStorage.getItem("username") || "Guest";
const welcomeEl = document.getElementById("welcome");
welcomeEl.innerText = `Welcome, ${username}`;
setTimeout(()=>{welcomeEl.style.opacity=0;},3000);

// Counter loop
(function counterLoop(){ updateCounter(); requestAnimationFrame(counterLoop); })();

// Logout
function logout() {
    saveProgress();
    window.location.href = 'login.html';
}
</script>
</body>
</html>
