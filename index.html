<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>New Blocks</title>
<style>
html, body { margin:0; padding:0; overflow:hidden; font-family: Arial; background:#f0f8ff; }
#toolbar { margin:5px; display:flex; flex-wrap:wrap; gap:5px; }
button, input[type=range] { margin:5px; padding:6px 12px; border:none; border-radius:5px; background:#007bff; color:white; cursor:pointer; }
button:hover { background:#0056b3; }
canvas { border:2px solid #007bff; display:block; margin:0 auto; background:white; }
</style>
</head>
<body>

<div id="toolbar">
  <button onclick="spawnBlock('rect')">Rectangle</button>
  <button onclick="spawnBlock('circle')">Circle</button>
  <button onclick="spawnBlock('ramp')">Ramp</button>
  <button onclick="resetCanvas()">Reset</button>
  <label>Gravity: <span id="gravityVal">9.8</span></label>
  <input type="range" id="gravitySlider" min="1" max="20" step="0.1" value="9.8" oninput="setGravity(this.value)">
  <button onclick="togglePause()">Pause/Unpause</button>
</div>

<canvas id="playground" width="900" height="500"></canvas>

<script>
const canvas = document.getElementById('playground');
const ctx = canvas.getContext('2d');
let blocks = [];
let paused = false;
let gravity = 9.8;
let lastTime = performance.now();

document.getElementById('gravitySlider').addEventListener('input', e=>{
  gravity = parseFloat(e.target.value);
  document.getElementById('gravityVal').textContent = gravity;
});

const friction = 0.99;
const bounce = 0.6;

class Block {
  constructor(type,x,y,angle=0){
    this.type=type;
    this.width=60;
    this.height=60;
    this.radius=30;
    this.length=120;
    this.x=x;
    this.y=y;
    this.vx=0;
    this.vy=0;
    this.color='#'+Math.floor(Math.random()*16777215).toString(16);
    this.mass = (type==='circle') ? Math.PI*this.radius*this.radius/100 : this.width*this.height/100;
    this.dragging=false;
    this.angle = angle;
  }

  draw(){
    ctx.fillStyle=this.color;
    if(this.type==='rect') ctx.fillRect(this.x,this.y,this.width,this.height);
    else if(this.type==='circle'){ ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fill(); }
    else if(this.type==='ramp'){
      ctx.save();
      ctx.translate(this.x,this.y);
      ctx.rotate(this.angle);
      ctx.fillRect(0,0,this.length,20);
      ctx.restore();
    }
  }

  update(dt){
    if(this.dragging || paused) return;
    this.vy += gravity*dt;
    this.vx *= friction;
    this.vy *= friction;
    this.x += this.vx;
    this.y += this.vy;

    // Wall collisions
    if(this.x<0){ this.x=0; this.vx*=-bounce; }
    if(this.type==='rect' && this.x+this.width>canvas.width){ this.x=canvas.width-this.width; this.vx*=-bounce; }
    if(this.type==='circle' && this.x+this.radius>canvas.width){ this.x=canvas.width-this.radius; this.vx*=-bounce; }
    if(this.type==='ramp' && this.x+this.length>canvas.width){ this.x=canvas.width-this.length; this.vx*=-bounce; }

    // Floor collisions
    if(this.type==='rect' && this.y+this.height>canvas.height){ this.y=canvas.height-this.height; this.vy*=-bounce; }
    if(this.type==='circle' && this.y+this.radius>canvas.height){ this.y=canvas.height-this.radius; this.vy*=-bounce; }
    if(this.type==='ramp' && this.y+20>canvas.height){ this.y=canvas.height-20; this.vy*=-bounce; }
  }
}

// Safe spawn without overlapping
function spawnBlock(type){
  let attempts=0;
  let x=0,y=0;
  while(attempts<100){
    x=50 + Math.random()*(canvas.width-150);
    y=50 + Math.random()*(canvas.height-150);
    let overlap = blocks.some(b=>{
      return Math.abs(b.x-x)<100 && Math.abs(b.y-y)<100;
    });
    if(!overlap) break;
    attempts++;
  }
  let angle=0;
  if(type==='ramp') angle = Math.random()*0.4-0.2; // slope ramps (-~23° to 23°)
  blocks.push(new Block(type,x,y,angle));
}

function togglePause(){ paused=!paused; }
function resetCanvas(){ blocks=[]; }
function setGravity(val){ gravity=parseFloat(val); document.getElementById('gravityVal').textContent=gravity; }

// Simple collision handling for demo
function handleCollisions(){
  for(let i=0;i<blocks.length;i++){
    for(let j=i+1;j<blocks.length;j++){
      const a=blocks[i], b=blocks[j];
      if(a.dragging || b.dragging) continue;
      // circle-circle
      if(a.type==='circle' && b.type==='circle') resolveCircleCircle(a,b);
      // rect-rect
      if(a.type==='rect' && b.type==='rect') resolveRectRect(a,b);
      // circle-rect
      if(a.type==='circle' && b.type==='rect') resolveCircleRect(a,b);
      if(a.type==='rect' && b.type==='circle') resolveCircleRect(b,a);
      // ramps
      if(a.type==='circle' && b.type==='ramp') resolveRamp(a,b);
      if(a.type==='rect' && b.type==='ramp') resolveRamp(a,b);
      if(b.type==='circle' && a.type==='ramp') resolveRamp(b,a);
      if(b.type==='rect' && a.type==='ramp') resolveRamp(b,a);
      if(a.type==='ramp' && b.type==='ramp') resolveRectRect(a,b);
    }
  }
}

function resolveCircleCircle(a,b){ /* same as before */ 
  let dx=b.x-a.x, dy=b.y-a.y;
  let dist=Math.sqrt(dx*dx+dy*dy);
  let minDist=a.radius+b.radius;
  if(dist<minDist){
    let nx=dx/dist||0, ny=dy/dist||1;
    let overlap=minDist-dist;
    let totalMass = a.mass+b.mass;
    a.x -= nx*overlap*(b.mass/totalMass); a.y -= ny*overlap*(b.mass/totalMass);
    b.x += nx*overlap*(a.mass/totalMass); b.y += ny*overlap*(a.mass/totalMass);
    let relVel = (b.vx-a.vx)*nx + (b.vy-a.vy)*ny;
    if(relVel>0) return;
    let impulse = -(1+bounce)*relVel/(1/a.mass+1/b.mass);
    a.vx -= impulse*nx/a.mass; a.vy -= impulse*ny/a.mass;
    b.vx += impulse*nx/b.mass; b.vy += impulse*ny/b.mass;
  }
}

function resolveRectRect(a,b){ /* simplified stacking */
  if(a.x<a.x+b.width && a.x+a.width>b.x && a.y<a.y+b.height && a.y+a.height>b.y){
    let overlapX = Math.min(a.x+a.width-b.x,b.x+b.width-a.x);
    let overlapY = Math.min(a.y+a.height-b.y,b.y+b.height-a.y);
    if(overlapX<overlapY){
      if(a.x<b.x) a.x-=overlapX; else a.x+=overlapX;
      [a.vx,b.vx] = [b.vx,a.vx];
    } else {
      if(a.y<b.y) a.y-=overlapY; else a.y+=overlapY;
      [a.vy,b.vy] = [b.vy*a.bounce,a.vy*b.bounce];
    }
  }
}

function resolveCircleRect(circle,rect){
  let nearestX = Math.max(rect.x, Math.min(circle.x, rect.x+rect.width));
  let nearestY = Math.max(rect.y, Math.min(circle.y, rect.y+rect.height));
  let dx = circle.x-nearestX, dy = circle.y-nearestY;
  let dist = Math.sqrt(dx*dx+dy*dy);
  if(dist<circle.radius){
    let nx=dx/dist||0, ny=dy/dist||1;
    let overlap = circle.radius-dist;
    circle.x+=nx*overlap; circle.y+=ny*overlap;
    circle.vx*=0.7; circle.vy*=0.7;
  }
}

function resolveRamp(obj,ramp){
  let rx=ramp.x, ry=ramp.y, angle=ramp.angle, length=ramp.length;
  let sin=Math.sin(angle), cos=Math.cos(angle);
  let rampY = sin*(obj.x-rx)+ry;
  let objY = (obj.type==='circle') ? obj.y-obj.radius : obj.y+obj.height;
  if(objY>rampY && objY<rampY+10){
    if(obj.type==='circle') obj.y=rampY+obj.radius;
    if(obj.type==='rect') obj.y=rampY-obj.height;
    obj.vx += gravity*sin*0.02;
    obj.vy = gravity*cos*0.02;
  }
}

// Drag & drop
let selected=null, offsetX=0, offsetY=0;
canvas.addEventListener('mousedown', e=>{
  const mx=e.offsetX,my=e.offsetY;
  for(let i=blocks.length-1;i>=0;i--){
    const b=blocks[i];
    let hit=false;
    if(b.type==='rect') hit=mx>b.x && mx<b.x+b.width && my>b.y && my<b.y+b.height;
    if(b.type==='circle') hit=(mx-b.x)**2+(my-b.y)**2<b.radius**2;
    if(b.type==='ramp') hit=mx>b.x && mx<b.x+b.length && my>b.y && my<b.y+20;
    if(hit){ selected=b; b.dragging=true; offsetX=mx-b.x; offsetY=my-b.y; break; }
  }
});
canvas.addEventListener('mousemove', e=>{ if(selected){ selected.x=e.offsetX-offsetX; selected.y=e.offsetY-offsetY; } });
canvas.addEventListener('mouseup', e=>{ if(selected) selected.dragging=false; selected=null; });

function animate(time){
  let dt = (time-lastTime)/1000;
  lastTime=time;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  handleCollisions();
  blocks.forEach(b=>b.update(dt));
  blocks.forEach(b=>b.draw());
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
</script>
</body>
</html>
