<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Interactive Physics Sandbox</title>
<style>
  body { margin: 0; overflow: hidden; background: #111; color: #fff; font-family: sans-serif; }
  #ui {
    position: absolute; top: 10px; left: 10px;
    background: rgba(0,0,0,0.5); padding: 10px; border-radius: 10px;
  }
  button, input { margin: 5px; padding: 5px; }
</style>
</head>
<body>
<canvas id="world"></canvas>
<div id="ui">
  <button onclick="spawn('circle')">Spawn Circle</button>
  <button onclick="spawn('square')">Spawn Square</button>
  <button onclick="spawn('ramp')">Spawn Ramp</button>
  <button onclick="resetWorld()">Reset</button>
  <button onclick="toggleGravity()">Pause/Play Gravity</button>
  <label>Gravity: <input id="gravitySlider" type="range" min="0" max="2" step="0.01" value="1" onchange="updateGravity(this.value)"></label>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
const { Engine, Render, Runner, World, Bodies, Body, Mouse, MouseConstraint, Events, Composite } = Matter;

// Engine & world
const engine = Engine.create();
const world = engine.world;

// Canvas & render
const canvas = document.getElementById('world');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const render = Render.create({
    canvas,
    engine,
    options: { wireframes: false, background: '#111', width: canvas.width, height: canvas.height }
});
Render.run(render);
Runner.run(Runner.create(), engine);

// Walls
const floorHeight = 100;
const walls = [
    Bodies.rectangle(canvas.width/2, canvas.height + floorHeight/2, canvas.width, floorHeight, { isStatic: true }),
    Bodies.rectangle(canvas.width/2, -50, canvas.width, 100, { isStatic: true }),
    Bodies.rectangle(-50, canvas.height/2, 100, canvas.height, { isStatic: true }),
    Bodies.rectangle(canvas.width+50, canvas.height/2, 100, canvas.height, { isStatic: true })
];
World.add(world, walls);

// Mouse
const mouse = Mouse.create(canvas);
const mouseConstraint = MouseConstraint.create(engine, { mouse, constraint: { stiffness: 0.2, render: { visible: false } } });
World.add(world, mouseConstraint);

// Keep track of ramps
const ramps = [];

// Spawn shapes
function spawn(type) {
    const x = Math.random() * (canvas.width - 100) + 50;
    const y = 50;
    let body;
    if (type === 'circle') body = Bodies.circle(x, y, 30, { restitution: 0.7, render: { fillStyle: '#f39c12' } });
    else if (type === 'square') body = Bodies.rectangle(x, y, 60, 60, { restitution: 0.7, render: { fillStyle: '#3498db' } });
    else if (type === 'ramp') {
        const widthRamp = 200, heightRamp = 20;
        const angle = 25 * Math.PI / 180;
        body = Bodies.rectangle(x, y+100, widthRamp, heightRamp, { 
            mass: 1000, 
            friction: 1, 
            restitution: 0.1,
            angle: angle, 
            render: { fillStyle: '#2ecc71' },
            plugin: { onFloor: false }
        });
        ramps.push(body);
    }
    World.add(world, body);
}

// Gravity control
let gravityEnabled = true;
function toggleGravity() {
    gravityEnabled = !gravityEnabled;
    engine.world.gravity.y = gravityEnabled ? parseFloat(document.getElementById('gravitySlider').value) : 0;
}
function updateGravity(value) {
    if (gravityEnabled) engine.world.gravity.y = parseFloat(value);
}

// Reset world
function resetWorld() {
    Composite.clear(world, false);
    World.add(world, walls);
    World.add(world, mouseConstraint);
    ramps.length = 0;
}

// Keep ramps at 25 degrees and floor-lock
Events.on(engine, 'beforeUpdate', () => {
    const fixedAngle = 25 * Math.PI / 180;

    ramps.forEach(ramp => {
        // Maintain angle
        Body.setAngle(ramp, fixedAngle);
        ramp.angularVelocity = 0;

        // Detect if ramp is on the floor (simple approximation)
        const floorY = canvas.height - floorHeight/2;
        if (ramp.position.y + ramp.bounds.max.y - ramp.position.y >= floorY - 1 && !mouseConstraint.body || mouseConstraint.body !== ramp) {
            Body.setVelocity(ramp, { x: 0, y: 0 });
            Body.setPosition(ramp, { x: ramp.position.x, y: floorY - (ramp.bounds.max.y - ramp.position.y) });
        }
    });
});

// Resize
window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    Body.setPosition(walls[0], { x: canvas.width/2, y: canvas.height + floorHeight/2 });
    Body.setPosition(walls[1], { x: canvas.width/2, y: -50 });
    Body.setPosition(walls[2], { x: -50, y: canvas.height/2 });
    Body.setPosition(walls[3], { x: canvas.width+50, y: canvas.height/2 });
});
</script>
</body>
</html>
